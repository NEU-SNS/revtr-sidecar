// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.3
// source: revtr.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RevtrClient is the client API for Revtr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RevtrClient interface {
	// Run reverse traceroutes
	RunRevtr(ctx context.Context, in *RunRevtrReq, opts ...grpc.CallOption) (*RunRevtrResp, error)
	// Internal. Should not be used
	GetRevtr(ctx context.Context, in *GetRevtrReq, opts ...grpc.CallOption) (*GetRevtrResp, error)
	// Internal. Should not be used
	GetRevtrByLabel(ctx context.Context, in *GetRevtrByLabelReq, opts ...grpc.CallOption) (*GetRevtrResp, error)
	// *
	// Internal. Should not be used
	GetRevtrMetaOnly(ctx context.Context, in *GetRevtrMetaOnlyReq, opts ...grpc.CallOption) (*GetRevtrMetaOnlyResp, error)
	// *
	// Internal. Should not be used, use GetRevtrMetaOnly instead
	GetRevtrBatchStatus(ctx context.Context, in *GetRevtrBatchStatusReq, opts ...grpc.CallOption) (*GetRevtrBatchStatusResp, error)
	// Internal. Should not be used
	UpdateRevtr(ctx context.Context, in *UpdateRevtrReq, opts ...grpc.CallOption) (*UpdateRevtrResp, error)
	// Get the available reverse traceroute sources.
	GetSources(ctx context.Context, in *GetSourcesReq, opts ...grpc.CallOption) (*GetSourcesResp, error)
	// *
	// Remove all the traceroutes of the atlas towards a source
	CleanAtlas(ctx context.Context, in *CleanAtlasReq, opts ...grpc.CallOption) (*CleanAtlasResp, error)
	// *
	// Runs a traceroute atlas towards a source
	RunAtlas(ctx context.Context, in *RunAtlasReq, opts ...grpc.CallOption) (*RunAtlasResp, error)
}

type revtrClient struct {
	cc grpc.ClientConnInterface
}

func NewRevtrClient(cc grpc.ClientConnInterface) RevtrClient {
	return &revtrClient{cc}
}

func (c *revtrClient) RunRevtr(ctx context.Context, in *RunRevtrReq, opts ...grpc.CallOption) (*RunRevtrResp, error) {
	out := new(RunRevtrResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/RunRevtr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) GetRevtr(ctx context.Context, in *GetRevtrReq, opts ...grpc.CallOption) (*GetRevtrResp, error) {
	out := new(GetRevtrResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/GetRevtr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) GetRevtrByLabel(ctx context.Context, in *GetRevtrByLabelReq, opts ...grpc.CallOption) (*GetRevtrResp, error) {
	out := new(GetRevtrResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/GetRevtrByLabel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) GetRevtrMetaOnly(ctx context.Context, in *GetRevtrMetaOnlyReq, opts ...grpc.CallOption) (*GetRevtrMetaOnlyResp, error) {
	out := new(GetRevtrMetaOnlyResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/GetRevtrMetaOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) GetRevtrBatchStatus(ctx context.Context, in *GetRevtrBatchStatusReq, opts ...grpc.CallOption) (*GetRevtrBatchStatusResp, error) {
	out := new(GetRevtrBatchStatusResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/GetRevtrBatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) UpdateRevtr(ctx context.Context, in *UpdateRevtrReq, opts ...grpc.CallOption) (*UpdateRevtrResp, error) {
	out := new(UpdateRevtrResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/UpdateRevtr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) GetSources(ctx context.Context, in *GetSourcesReq, opts ...grpc.CallOption) (*GetSourcesResp, error) {
	out := new(GetSourcesResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/GetSources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) CleanAtlas(ctx context.Context, in *CleanAtlasReq, opts ...grpc.CallOption) (*CleanAtlasResp, error) {
	out := new(CleanAtlasResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/CleanAtlas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *revtrClient) RunAtlas(ctx context.Context, in *RunAtlasReq, opts ...grpc.CallOption) (*RunAtlasResp, error) {
	out := new(RunAtlasResp)
	err := c.cc.Invoke(ctx, "/pb.Revtr/RunAtlas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RevtrServer is the server API for Revtr service.
// All implementations should embed UnimplementedRevtrServer
// for forward compatibility
type RevtrServer interface {
	// Run reverse traceroutes
	RunRevtr(context.Context, *RunRevtrReq) (*RunRevtrResp, error)
	// Internal. Should not be used
	GetRevtr(context.Context, *GetRevtrReq) (*GetRevtrResp, error)
	// Internal. Should not be used
	GetRevtrByLabel(context.Context, *GetRevtrByLabelReq) (*GetRevtrResp, error)
	// *
	// Internal. Should not be used
	GetRevtrMetaOnly(context.Context, *GetRevtrMetaOnlyReq) (*GetRevtrMetaOnlyResp, error)
	// *
	// Internal. Should not be used, use GetRevtrMetaOnly instead
	GetRevtrBatchStatus(context.Context, *GetRevtrBatchStatusReq) (*GetRevtrBatchStatusResp, error)
	// Internal. Should not be used
	UpdateRevtr(context.Context, *UpdateRevtrReq) (*UpdateRevtrResp, error)
	// Get the available reverse traceroute sources.
	GetSources(context.Context, *GetSourcesReq) (*GetSourcesResp, error)
	// *
	// Remove all the traceroutes of the atlas towards a source
	CleanAtlas(context.Context, *CleanAtlasReq) (*CleanAtlasResp, error)
	// *
	// Runs a traceroute atlas towards a source
	RunAtlas(context.Context, *RunAtlasReq) (*RunAtlasResp, error)
}

// UnimplementedRevtrServer should be embedded to have forward compatible implementations.
type UnimplementedRevtrServer struct {
}

func (UnimplementedRevtrServer) RunRevtr(context.Context, *RunRevtrReq) (*RunRevtrResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunRevtr not implemented")
}
func (UnimplementedRevtrServer) GetRevtr(context.Context, *GetRevtrReq) (*GetRevtrResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevtr not implemented")
}
func (UnimplementedRevtrServer) GetRevtrByLabel(context.Context, *GetRevtrByLabelReq) (*GetRevtrResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevtrByLabel not implemented")
}
func (UnimplementedRevtrServer) GetRevtrMetaOnly(context.Context, *GetRevtrMetaOnlyReq) (*GetRevtrMetaOnlyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevtrMetaOnly not implemented")
}
func (UnimplementedRevtrServer) GetRevtrBatchStatus(context.Context, *GetRevtrBatchStatusReq) (*GetRevtrBatchStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevtrBatchStatus not implemented")
}
func (UnimplementedRevtrServer) UpdateRevtr(context.Context, *UpdateRevtrReq) (*UpdateRevtrResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRevtr not implemented")
}
func (UnimplementedRevtrServer) GetSources(context.Context, *GetSourcesReq) (*GetSourcesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSources not implemented")
}
func (UnimplementedRevtrServer) CleanAtlas(context.Context, *CleanAtlasReq) (*CleanAtlasResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanAtlas not implemented")
}
func (UnimplementedRevtrServer) RunAtlas(context.Context, *RunAtlasReq) (*RunAtlasResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunAtlas not implemented")
}

// UnsafeRevtrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RevtrServer will
// result in compilation errors.
type UnsafeRevtrServer interface {
	mustEmbedUnimplementedRevtrServer()
}

func RegisterRevtrServer(s grpc.ServiceRegistrar, srv RevtrServer) {
	s.RegisterService(&Revtr_ServiceDesc, srv)
}

func _Revtr_RunRevtr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRevtrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).RunRevtr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/RunRevtr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).RunRevtr(ctx, req.(*RunRevtrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_GetRevtr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevtrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).GetRevtr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/GetRevtr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).GetRevtr(ctx, req.(*GetRevtrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_GetRevtrByLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevtrByLabelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).GetRevtrByLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/GetRevtrByLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).GetRevtrByLabel(ctx, req.(*GetRevtrByLabelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_GetRevtrMetaOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevtrMetaOnlyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).GetRevtrMetaOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/GetRevtrMetaOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).GetRevtrMetaOnly(ctx, req.(*GetRevtrMetaOnlyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_GetRevtrBatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevtrBatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).GetRevtrBatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/GetRevtrBatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).GetRevtrBatchStatus(ctx, req.(*GetRevtrBatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_UpdateRevtr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRevtrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).UpdateRevtr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/UpdateRevtr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).UpdateRevtr(ctx, req.(*UpdateRevtrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_GetSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSourcesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).GetSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/GetSources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).GetSources(ctx, req.(*GetSourcesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_CleanAtlas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanAtlasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).CleanAtlas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/CleanAtlas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).CleanAtlas(ctx, req.(*CleanAtlasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Revtr_RunAtlas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunAtlasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RevtrServer).RunAtlas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Revtr/RunAtlas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RevtrServer).RunAtlas(ctx, req.(*RunAtlasReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Revtr_ServiceDesc is the grpc.ServiceDesc for Revtr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Revtr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Revtr",
	HandlerType: (*RevtrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunRevtr",
			Handler:    _Revtr_RunRevtr_Handler,
		},
		{
			MethodName: "GetRevtr",
			Handler:    _Revtr_GetRevtr_Handler,
		},
		{
			MethodName: "GetRevtrByLabel",
			Handler:    _Revtr_GetRevtrByLabel_Handler,
		},
		{
			MethodName: "GetRevtrMetaOnly",
			Handler:    _Revtr_GetRevtrMetaOnly_Handler,
		},
		{
			MethodName: "GetRevtrBatchStatus",
			Handler:    _Revtr_GetRevtrBatchStatus_Handler,
		},
		{
			MethodName: "UpdateRevtr",
			Handler:    _Revtr_UpdateRevtr_Handler,
		},
		{
			MethodName: "GetSources",
			Handler:    _Revtr_GetSources_Handler,
		},
		{
			MethodName: "CleanAtlas",
			Handler:    _Revtr_CleanAtlas_Handler,
		},
		{
			MethodName: "RunAtlas",
			Handler:    _Revtr_RunAtlas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "revtr.proto",
}
